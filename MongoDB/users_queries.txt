// **********************************************************************
//    Query 1. Find all users who have a profile location of "New York".
// ********************************************************************** 

MQL:					db.users.find({ "profile.location": "New York" })

Compass Query Bar: 		{ "profile.location": "New York" }




/* **********************************************************************
    Query 2. Find average age of all users.
********************************************************************** */

db.users.aggregate([
  {
    $group: {
      _id: null, // Group all documents together

      averageAge: {
        $avg: "$age" // Calculate the average of the 'age' field
      }
    }
  }
])





/* **********************************************************************
    Query 3. Find all the posts made by "bob". (use the username or _id)
********************************************************************** */

MQL: 		db.users.find({ username: "bob" }, { posts: 1 })
			db.users.find({ _id: "507f191e810c19729de860eb" }, { posts: 1 })


db.users.aggregate([
  {
    // Stage 1: Filter to find the user 'bob'
    $match: {
      username: "bob"
    }
  },
  {
    // Stage 2: Project (select) only the 'posts' field
    $project: {
      posts: 1
      // Note: _id is included by default unless explicitly excluded with _id: 0
    }
  }
])





/* **********************************************************************
    Query 4. Retrieve the content of all posts made by Bob

$unwind: 
    -- Deconstructs the posts array field, creating a new document for each element in the array. 
    -- If the posts field contains 5 elements, this stage will output 5 documents, each containing one of Bob's posts

$replaceRoot:
	-- Replaces the entire input document with the value of the posts field. 
	-- Since $unwind has already run, the posts field now holds a single post object (the individual element from the array). 
	-- This basically promotes the post object to become the new root document.

********************************************************************** */

db.users.aggregate(
  [
    { $match: { username: 'bob' } },

    { $unwind: { path: '$posts' } },

    { $replaceRoot: { newRoot: '$posts' } },

    { $project: { content: 1 } }
  ]
);



/* **********************************************************************
    Query 5. Who does alice follow?

	$lookup stage is comparable to a LEFT OUTER JOIN in SQL.
	It's used to combine documents (rows) from the current collection with related documents (rows) 
	from another table or, in this case, the same collection.

	In SQL, a JOIN produces new rows for every match. If Alice follows three people, the SQL join 
	would produce three rows, each containing Alice's details plus one of the followed users' details.

	In MongoDB, the $lookup is array-oriented: it keeps Alice's document as a single document and embeds 
	the three matched users' details into the single followedUserDetails array. This is often described 
	as denormalization on the fly.
********************************************************************** */
db.users.aggregate(
  [
    {
      $match: { _id: '507f191e810c19729de860ea' }
    },
    {
      $lookup: {
        from: 'users',
        localField: 'following',
        foreignField: '_id',
        as: 'followedUserDetails'
      }
    },
    { $unwind: '$followedUserDetails' },
    {
      $project: {
        _id: 0,
        username: '$followedUserDetails.username',
        email: '$followedUserDetails.email'
      }
    }
  ]
)



/* **********************************************************************
    Query 6. Count number of followers for each user.
********************************************************************** */
db.users.aggregate([
  // Stage 1: Calculate the follower count for each user
  {
    $project: {
      _id: 0,
      followerCount: {
        $size: "$followers"
      }
    }
  },
  // Stage 2: Group all documents and calculate the average
  {
    $group: {
      _id: null, // Group all documents into one
      averageFollowerCount: {
        $avg: "$followerCount" // Calculate the average of the newly created field
      }
    }
  }
])



/* **********************************************************************
    Query 7. Find the user with the most followers.
********************************************************************** */

db.users.aggregate([
  {
    // Stage 1: Calculate the size of the 'following' array
    $project: {
      username: 1,
      _id: 0,
      followingCount: {
        $size: "$following"
      }
    }
  },
  {
    // Stage 2: Sort by the count in descending order (-1)
    $sort: {
      followingCount: -1
    }
  },
  {
    // Stage 3: Limit the results to the top 3
    $limit: 3
  }
])




/* **********************************************************************
    Query 8. Display the last post for every user.
********************************************************************** */
db.users.aggregate([
  {
    $project: {
      username: 1,
      lastPost: {
        $arrayElemAt: ["$posts", -1]
      }
    }
  },
  {
    $project: {
      username: 1,
      _id: 0,
      postContent: "$lastPost.content",
      postDate: "$lastPost.createdAt"
    }
  }
])



/* **********************************************************************
    Query 9. Find users who are Travel enthusiasts (e.g., "Travel" in Bio)
********************************************************************** */
db.users.aggregate([
  {
    $match: {
      "profile.bio": { $regex: "travel", $options: "i"}
    }
  },
  {
    $project: {
      username: 1,
      _id: 0,
      email: 1,
      profileBio: "$profile.bio"
    }
  }
])


/* **********************************************************************
    Query 10. Find users who have at least 2 followers and are following
              at least 2 people. Then, sort these users by the number of
              followers they have.

              (Social Media Analytics)


	The $size operator is used to get the length of an array,
	and it doesn't work with comparison operators like $gte directly
	inside the $size expression.

	Instead, we need to compare the array length directly using the $expr
	operator or use a $gt condition to filter based on the size of the array.

********************************************************************** */

db.users.aggregate([

  // 1. Match users who have at least 2 followers and are following at least 2 people
  {
    $match: {
      $and: [
        { $expr: { $gte: [{ $size: "$followers" }, 2] } },  // At least 2 followers
        { $expr: { $gte: [{ $size: "$following" }, 2] } }   // Following at least 2 people
      ]
    }
  },

  // 2. Add a new field for the follower count (size of the "followers" array)
  {
    $addFields: {
      followerCount: { $size: "$followers" }  // Count the number of followers
    }
  },

  // 3. Sort users by follower count (descending order)
  {
    $sort: { followerCount: -1 }
  },

  // 4. Project the final output: username, email, and follower count
  {
    $project: {
      username: 1,
      email: 1,
      followerCount: 1,
      _id: 0
    }
  }
])






