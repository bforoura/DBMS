<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL vs MongoDB Commands</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        table, th, td {
            border: 1px solid #ddd;
        }
        th, td {
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #4CAF50;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .explanation {
            margin-bottom: 20px;
            font-size: 1.1em;
        }
        .category-title {
            font-weight: bold;
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <h1>SQL vs MongoDB Commands</h1>

    <div class="explanation">
        <p><span class="category-title">Database and Collection Management:</span> This category covers operations related to creating or removing databases and collections (tables in SQL). MongoDB automatically creates a database when you first use it, and collections can be created implicitly or explicitly.</p>

        <p><span class="category-title">CRUD Operations:</span> CRUD stands for Create, Read, Update, and Delete. These are the fundamental operations for working with data. MongoDB’s `find()` command is the equivalent of SQL’s `SELECT`, and `updateOne()`/`deleteOne()` are for updating and deleting specific documents.</p>

        <p><span class="category-title">Schema and Field Management:</span> SQL typically requires explicit schema modifications, like adding columns to a table. MongoDB, on the other hand, allows for dynamic schema, where fields can be added directly to documents on the fly, without altering the collection’s structure.</p>

        <p><span class="category-title">Data Retrieval and Aggregation:</span> SQL provides powerful querying capabilities through `SELECT`, `GROUP BY`, and aggregate functions. MongoDB's `aggregate()` method is used for more complex queries and data transformations, including grouping and aggregating data.</p>

        <p><span class="category-title">Indexing:</span> Both SQL and MongoDB use indexes to optimize query performance. MongoDB supports compound indexes and allows for indexing individual fields.</p>

        <p><span class="category-title">Join Operations:</span> SQL uses `JOIN` to combine data from multiple tables. MongoDB handles joins through the `$lookup` operator in its aggregation framework, which allows you to combine data from different collections.</p>
    </div>

    <table>
        <thead>
            <tr>
                <th>Category</th>
                <th>Operation</th>
                <th>SQL Command</th>
                <th>MongoDB Command</th>
                <th>Example SQL</th>
                <th>Example MongoDB</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><b>Database and Collection Management</b></td>
                <td><b>Create Database</b></td>
                <td>CREATE DATABASE</td>
                <td>MongoDB creates database implicitly when first used</td>
                <td>CREATE DATABASE mydb;</td>
                <td>use mydb;</td>
            </tr>
            <tr>
                <td></td>
                <td><b>Create Table (Collection)</b></td>
                <td>CREATE TABLE</td>
                <td>db.createCollection()</td>
                <td>CREATE TABLE users (id INT, name VARCHAR(100));</td>
                <td>db.createCollection('users')</td>
            </tr>
            <tr>
                <td></td>
                <td><b>Drop Table (Collection)</b></td>
                <td>DROP TABLE</td>
                <td>db.collection.drop()</td>
                <td>DROP TABLE users;</td>
                <td>db.users.drop()</td>
            </tr>
            <tr>
                <td><b>CRUD Operations</b></td>
                <td><b>Insert Data</b></td>
                <td>INSERT INTO</td>
                <td>db.collection.insertOne() / insertMany()</td>
                <td>INSERT INTO users (id, name) VALUES (1, 'Alice');</td>
                <td>db.users.insertOne({id: 1, name: 'Alice'})</td>
            </tr>
            <tr>
                <td></td>
                <td><b>Select Data</b></td>
                <td>SELECT</td>
                <td>db.collection.find()</td>
                <td>SELECT * FROM users WHERE id = 1;</td>
                <td>db.users.find({id: 1})</td>
            </tr>
            <tr>
                <td></td>
                <td><b>Select All Data</b></td>
                <td>SELECT * FROM</td>
                <td>db.collection.find()</td>
                <td>SELECT * FROM users;</td>
                <td>db.users.find()</td>
            </tr>
            <tr>
                <td></td>
                <td><b>Update Data</b></td>
                <td>UPDATE</td>
                <td>db.collection.updateOne() / updateMany()</td>
                <td>UPDATE users SET name = 'Bob' WHERE id = 1;</td>
                <td>db.users.updateOne({id: 1}, {$set: {name: 'Bob'}})</td>
            </tr>
            <tr>
                <td></td>
                <td><b>Delete Data</b></td>
                <td>DELETE</td>
                <td>db.collection.deleteOne() / deleteMany()</td>
                <td>DELETE FROM users WHERE id = 1;</td>
                <td>db.users.deleteOne({id: 1})</td>
            </tr>
            <tr>
                <td><b>Schema and Field Management</b></td>
                <td><b>Add Column (Field)</b></td>
                <td>ALTER TABLE ADD COLUMN</td>
                <td>No direct equivalent; add field on the fly during insert or update</td>
                <td>ALTER TABLE users ADD COLUMN age INT;</td>
                <td>db.users.updateMany({}, {$set: {age: 30}})</td>
            </tr>
            <tr>
                <td></td>
                <td><b>Dynamically Add Fields to Documents</b></td>
                <td>No direct equivalent</td>
                <td>No equivalent command, fields are added directly when inserting or updating documents</td>
                <td>N/A</td>
                <td>db.users.updateOne({name: "Alice"}, {$set: {email: "alice@example.com"}})</td>
            </tr>
            <tr>
                <td><b>Data Retrieval and Aggregation</b></td>
                <td><b>Select Specific Fields</b></td>
                <td>SELECT column1, column2</td>
                <td>db.collection.find({}, {field1: 1, field2: 1})</td>
                <td>SELECT name, age FROM users;</td>
                <td>db.users.find({}, {name: 1, age: 1})</td>
            </tr>
            <tr>
                <td></td>
                <td><b>Count Records</b></td>
                <td>SELECT COUNT(*)</td>
                <td>db.collection.countDocuments()</td>
                <td>SELECT COUNT(*) FROM users;</td>
                <td>db.users.countDocuments()</td>
            </tr>
            <tr>
                <td></td>
                <td><b>Distinct Values</b></td>
                <td>SELECT DISTINCT</td>
                <td>db.collection.distinct()</td>
                <td>SELECT DISTINCT name FROM users;</td>
                <td>db.users.distinct('name')</td>
            </tr>
            <tr>
                <td></td>
                <td><b>Group Data</b></td>
                <td>GROUP BY</td>
                <td>db.collection.aggregate()</td>
                <td>SELECT COUNT(*), city FROM users GROUP BY city;</td>
                <td>db.users.aggregate([{$group: {_id: "$city", count: {$sum: 1}}}])</td>
            </tr>
            <tr>
                <td><b>Indexing</b></td>
                <td><b>Create Index</b></td>
                <td>CREATE INDEX</td>
                <td>db.collection.createIndex()</td>
                <td>CREATE INDEX idx_name ON users (name);</td>
                <td>db.users.createIndex({name: 1})</td>
            </tr>
            <tr>
                <td><b>Join Operations</b></td>
                <td><b>Join Tables (Collections)</b></td>
                <td>JOIN</td>
                <td>$lookup</td>
                <td>SELECT * FROM orders JOIN customers ON orders.customer_id = customers.id;</td>
                <td>db.orders.aggregate([{$lookup: {from: 'customers', localField: 'customer_id', foreignField: '_id', as: 'customer'}}])</td>
            </tr>
        </tbody>
    </table>
</body>
</html>
