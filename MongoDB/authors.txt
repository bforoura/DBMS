db.authors.insertMany([
  {
    "name": "Jane Austen",
    "birth_year": 1775,
    "country": "England"
  },
  {
    "name": "Mark Twain",
    "birth_year": 1835,
    "country": "USA",
    "pen_name_of": "Samuel Clemens"
  },
  {
    "name": "Gabriel García Márquez",
    "birth_year": 1927,
    "country": "Colombia"
  },
  {
    "name": "Virginia Woolf",
    "birth_year": 1882,
    "country": "England"
  },
  {
    "name": "Toni Morrison",
    "birth_year": 1931,
    "country": "USA"
  }
]);

===================================================================================================
Query 1
=======
SQL ==> DELETE FROM authors;
MQL ==> db.authors.deleteMany({});


Query 2
=======
DROP TABLE authors;	
db.authors.drop()


Query3
=======
DESC authors;
db.authors.findOne();


Query 4
=======
SQL ==> SELECT * FROM authors;
MQL ==> db.authors.find({});

// The db.authors.aggregate() method takes an array of stages that process the documents sequentially.
// The $match stage is used to filter documents based on specified criteria. It's essentially the aggregation 
// equivalent of the query document in a find() operation.

// Why Use Aggregation?
// For simply retrieving all documents, the find({}) method is much simpler and more efficient.
// However, you would use the aggregate pipeline if you immediately needed to perform further processing on all the documents, such as:
//          $group  (e.g., group authors by country).
//          $project  (e.g., reshape the output fields).
//          $sort  (e.g., sort all authors by birth year).
//          $limit the results.


db.authors.aggregate([
  {
    $match: {}
  }
]);





Query 5
=======
SELECT name 
FROM authors;

db.authors.find({}, {"name":1})
db.authors.find({}, {"name":1, "_id":0})

db.authors.aggregate([
  {
    $project: {
      name: 1,
      _id: 0
    }
  }
]);



Query 6
=======
SELECT name, country 
FROM authors;

db.authors.find({}, {"name":1, "country":1, "_id":0})

db.authors.aggregate([
  {
    $project: {
      name: 1,
      country: 1,
      _id: 0
    }
  }
]);



Query 7
=======
SELECT name, country 
FROM authors
ORDER BY country;

db.authors.find({}, {"name":1, "country":1, "_id":0}).sort({"country":1})

// A pipeline in MongoDB refers to the Aggregation Pipeline, a framework to process documents and return computed results. 
// It allows you to perform multi-stage data processing where documents are transformed from one stage to the next until 
// a final result is produced

db.authors.aggregate([
  {
    $project: {
      name: 1,
      country: 1,
      _id: 0
    }
  },
  {
    $sort: {
      country: 1
    }
  }
]);




Query 8
=======
SELECT name, country 
FROM authors
ORDER BY country DESC
LIMIT 1;

db.authors.find({}, {"_id":0}).sort({"birth_year":-1}).limit(1)

db.authors.aggregate([
  {
    $sort: {
      birth_year: -1
    }
  },
  {
    $limit: 1
  },
  {
    $project: {
      _id: 0
    }
  }
]);




Query 9
=======
SELECT name, country 
FROM authors
WHERE birth_year < 1800;

db.authors.find(
    { "birth_year": { $lt: 1800 } },       // Filter: Authors born before 1800
    { "name": 1, "country": 1, "_id": 0 }  // Projection: Show name and country, hide _id
)


db.authors.aggregate([
  {
    $match: {
      birth_year: { $lt: 1800 }
    }
  },
  {
    $project: {
      name: 1,
      country: 1,
      _id: 0
    }
  }
]);





Query 10
========
SELECT name, country 
FROM authors
WHERE birth_year >= 1900;

db.authors.find(
    { "birth_year": { $gte: 1900 } },      
    { "name": 1, "country": 1, "_id": 0 }   
)


db.authors.aggregate([
  {
    $match: {
      birth_year: { $gte: 1900 }
    }
  },
  {
    $project: {
      name: 1,
      country: 1,
      _id: 0
    }
  }
]);






Query 11
========
SELECT name, country 
FROM authors
WHERE birth_year BETWEEN 1800 AND 1900;

db.authors.find(
    {"birth_year": {$gte: 1800, $lte: 1900} },    // AND implied
    {"name": 1, "country": 1, "_id": 0 } 
)

db.authors.aggregate([
  {
    $match: {
      birth_year: { $gte: 1800, $lte: 1900 }
    }
  },
  {
    $project: {
      name: 1,
      country: 1,
      _id: 0
    }
  }
]);




Query 12
========
SELECT name, country 
FROM authors
WHERE birth_year < 1800 OR birth_year > 1900;

db.authors.find(
    { $or: [
              { "birth_year": { $lt: 1800 } },  
              { "birth_year": { $gt: 1900 } }   
           ]
    },
    { "name": 1, "country": 1, "_id": 0 }  
)

db.authors.aggregate([
  {
    $match: {
      $or: [
        { birth_year: { $lt: 1800 } }, // Authors born before 1800
        { birth_year: { $gt: 1900 } }  // Authors born after 1900
      ]
    }
  },
  {
    $project: {
      name: 1,
      country: 1,
      _id: 0
    }
  }
]);





Query 13
========
SELECT country, COUNT(*) 
FROM authors GROUP BY country;

db.authors.aggregate([
  {
    $group: {
      _id: "$country",               // 1. GROUP BY: Group all documents by the value of the 'country' field
      author_count: { $sum: 1 }      // 2. COUNT: Create a new field 'author_count' by summing 1 for every document in the group
    }
  }
])



Query 14
========
SELECT min(birth_year)
FROM authors;


db.authors.aggregate([
  {
    $group: {
      _id: null,                                     // Group all documents together
      earliest_year: { $min: "$birth_year" }         // Try max(), avg()
    }
  }
])




Query 15
========

SELECT country, COUNT(*) 
FROM authors GROUP BY country
order by count(*)
limit 1;


// $limit BEFORE $project (Recommended for Efficiency)
//  When your goal is to reduce the number of documents in the pipeline before applying the projection. 
// This is the most common and most efficient sequence.

// Applying $limit early ensures that the $project stage only has to process a small subset of documents, 
// reducing the overall workload. The system doesn't waste resources transforming fields in documents that 
// will ultimately be discarded by the limit.


db.authors.aggregate([
  // 1. GROUP and COUNT
  {
    $group: {
      _id: "$country",               // Group by country
      author_count: { $sum: 1 }      // Count authors in each group
    }
  },
  
  // 2. SORT to find the Minimum Count
  {
    $sort: { author_count: 1 }       // Sort counts ASCENDING (1)
  },
  
  // 3. LIMIT to the Minimum Count
  {
    $limit: 1                        // Take only the top group (the one with the minimum count)
  },
  
  // 4. PROJECT (Optional: Rename/Reformat)
  {
    $project: {
      _id: 0,                        // Exclude the internal _id
      country: "$_id",               // Rename the group key to 'country'
      author_count: 1
    }
  }
])



====================================================================================================
Resources: 
    https://www.mongodb.com/docs/manual/tutorial/query-documents/
    https://www.mongodb.com/docs/manual/aggregation/
====================================================================================================


